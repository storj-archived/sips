```
Title: Deterministic Bucket and File Ids
Author: Chris Pollard <chris@storj.io>
Status: Draft
Type: Standard
Created: 2016-10-23
```

Abstract
--------

Calculate bucket IDs and file IDs deterministically based on the user ID, bucket name, and file name. This should allow direct file and bucket lookups by name and allow users to know the IDs before creation, which is required for the HD file key update. This method of generating deterministic IDs will still avoid conflicts across users and across buckets.

Motivation
----------

Storj currently uses autogenerated Mongo IDs for new files and buckets. This ID is returned to users after the creation request. All Storj users must then keep track of and assosciate these ids with the original file themselves.

This SIP proposes making these ids calculated deterministically directly by user ID (email or public key), bucket name, and file name. Specifically, the bucket ID will be the first 12 bytes of `sha256rmd160(userId + bucketName)` and the file id will be the first 12 bytes of `sha256rmd160(bucketId + fileName)`. Taking the hex encoded first twelve bytes will ensure this is compatible with the older Mongo IDs.

Deterministic IDs allow the user to "lookup" resources client-side without needing to list all buckets or list all the files in a bucket. This will allow for a more intuitive programming interface, since users can refer to buckets and files by name instead of id and suffer no performance penalty. It will allow web developers to reference files and buckets by name when the browser javascript library is created.


Specification
-------------

The bucket id will equal the hex encoded value of the first twelve bytes of the user id concatenated with bucket name. The file id will equal the hex encoded value of the first twelve bytes of the bucket id concatenated with the file name. The Javascript implementation taken from core/lib/utils.js is shown below.

```javascript
var calculateBucketId = function(user, bucketName) {
  var hash = rmd160sha256(user + bucketName, 'utf-8');
  return hash.substring(0, 24);
};

var calculateFileId = function(bucketId, fileName) {
  var hash = rmd160sha256(bucketId + fileName, 'utf-8');
  return hash.substring(0, 24);
};

```

Handling Conflicts
------------------

Users can no longer upload files with the same name to the same bucket, nor create multiple buckets with the same name. Instead of throwing an error when uploading a file of the same name, core-cli should make the name unique. It can do this by prepending the current time as an ISO String enclosed in parenthesis. If this string is detected when a user requests to download the file, it can be stripped to restore the original file name. For example:

```javascript
// creating the new file name
var newFileName = '(' + new Date().toISOString() + ') ' + originalFileName;
```

```javascript
// stripping the date from the file beginning

var _stripISOString = function(fileName){
  var array = fileName.split(' ');
  var potentialDate = array[0];
  var re = /\(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z\)/g;
  var isValid = potentialDate.match(re);
  if (isValid){
    return array.splice(1).join(' ');
  } else {
    return fileName
  }
};
```

Reference By Name
-----------------

Core-CLI should be updated to acccept either bucket IDs or bucket names, as well as file IDs or file names. Core-CLI can check whether the supplied argument is a valid Mongo ID, If not, it should treat it as a name and use the deterministic id calculation functions to calculate IDs. If it is, it should be treated as an ID as usual. Some users might want to name their buckets with valid Mongo IDs. If so, they can supply a new --by-name flag to core-cli which will force the valid mongo ids to be treated as names.